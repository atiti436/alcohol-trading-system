# 🚨 防止重複錯誤檢查清單

## ⚠️ **問題根源分析**

### **WHY會重複犯錯？**
1. **知道 ≠ 執行** - 寫了教訓但沒有強制執行
2. **範圍估計不足** - 沒有系統性分析影響範圍
3. **AI模式匹配局限** - 只修復看到的錯誤，沒有全域思維
4. **缺乏檢查清單** - 沒有標準化的驗證流程
5. **指令理解偏差** - AI理解為"修復這個"而非"修復這類"

---

## 📋 **強制執行檢查清單**

### **🤖 AI 系統性思維強制執行機制**

#### **當螞蟻看到任何錯誤時，強制執行以下步驟：**

**❌ 絕對禁止的錯誤做法：**
```
看到錯誤 → 立即修復這個錯誤 → 提交 ❌
```

**✅ 強制執行的正確做法：**
```bash
# 步驟1: 分析錯誤模式（必須執行）
echo "🔍 步驟1: 分析錯誤模式..."

# 步驟2: 全域搜尋相同錯誤模式（必須執行）
grep -rn "錯誤模式" webapp/src/

# 步驟3: 記錄所有找到的實例（必須執行）
echo "📋 找到以下相同錯誤實例："
grep -rn "錯誤模式" webapp/src/ | wc -l
echo "總共需要修復的地方: $(grep -rn '錯誤模式' webapp/src/ | wc -l) 處"

# 步驟4: 批量修復所有實例（必須執行）
# 逐一修復每個找到的錯誤

# 步驟5: 再次驗證無遺漏（必須執行）
grep -rn "錯誤模式" webapp/src/
echo "🎯 如果有任何輸出，表示還有遺漏！"
```

### **🔍 第一步：資料庫模型變更檢查**
當修改任何 Prisma 模型時，**必須執行**：

```bash
# 1. 全域搜尋舊欄位名稱
grep -r "舊欄位名" webapp/src/

# 2. 搜尋模型相關的創建和查詢
grep -r "ModelName.create\|ModelName.aggregate\|ModelName.groupBy" webapp/src/

# 3. 搜尋類型引用
grep -r "ModelNameCreateInput\|ModelNameWhereInput" webapp/src/
```

### **🔧 第二步：TypeScript類型檢查**
```bash
# 1. 重新生成 Prisma Client
npx prisma generate

# 2. 完整編譯檢查
npm run build

# 3. 欄位命名檢查
npm run check:fields
```

### **📝 第三步：影響範圍分析**
對於 InventoryMovement 模型變更，檢查：
- [ ] `inventoryMovement.create` - 所有創建點
- [ ] `inventoryMovement.aggregate` - 所有聚合查詢
- [ ] `inventoryMovement.groupBy` - 所有分組查詢
- [ ] `_sum`, `_avg`, `_count` - 所有統計查詢
- [ ] API 回應欄位 - 前端顯示欄位

---

## 🎯 **標準化修復流程**

### **Step 1: 停止急於修復**
❌ **錯誤做法**: 看到錯誤 → 立刻修 → 立刻推送
✅ **正確做法**: 看到錯誤 → 分析範圍 → 全域檢查 → 一次修完

### **Step 2: 建立影響範圍地圖**
```
InventoryMovement 模型變更影響：
├── API 創建 (3個檔案)
│   ├── inventory/route.ts
│   ├── purchases/[id]/receive/route.ts
│   └── sales/[id]/ship/route.ts
├── API 查詢 (2個檔案)
│   ├── inventory/movements/route.ts
│   └── reports/route.ts
└── 前端顯示欄位
    └── 所有使用庫存異動的UI組件
```

### **Step 3: 批次修正確認**
- [ ] 所有API檔案修正完成
- [ ] 本機編譯無錯誤
- [ ] 欄位命名檢查通過
- [ ] Prisma Client重新生成
- [ ] 一次性推送

---

## 🤖 **自動化檢查腳本**

### **1. InventoryMovement 完整檢查腳本**
```bash
#!/bin/bash
# check-inventory-movement.sh

echo "🔍 檢查 InventoryMovement 相關錯誤..."
echo "=========================================="

echo "❌ 檢查是否使用舊欄位 'quantity'："
grep -rn "quantity.*:" webapp/src/ | grep -v "quantity_before\|quantity_change\|quantity_after" | grep "inventoryMovement\|InventoryMovement"

echo ""
echo "📋 檢查 create 操作是否使用正確欄位："
grep -rn "inventoryMovement\.create\|InventoryMovement.*create" webapp/src/ -A 10 | grep -E "quantity[^_]|previous_stock|new_stock"

echo ""
echo "📊 檢查 _sum/_avg 聚合是否使用正確欄位："
grep -rn "_sum.*quantity[^_]\|_avg.*quantity[^_]" webapp/src/

echo ""
echo "🔧 檢查正確欄位使用狀況："
echo "✅ quantity_before 使用次數: $(grep -r "quantity_before" webapp/src/ | wc -l)"
echo "✅ quantity_change 使用次數: $(grep -r "quantity_change" webapp/src/ | wc -l)"
echo "✅ quantity_after 使用次數: $(grep -r "quantity_after" webapp/src/ | wc -l)"

echo ""
echo "🚨 如有任何錯誤輸出，表示仍有舊欄位使用！"
```

### **2. 欄位命名一致性檢查**
```bash
#!/bin/bash
# check-field-naming.sh

echo "🔍 檢查欄位命名一致性..."
echo "=========================================="

echo "❌ 檢查 camelCase vs snake_case 不一致："
grep -rn "variantCode\|productCode\|saleNumber" webapp/src/ | grep -v "// TODO"

echo ""
echo "✅ 檢查正確的 snake_case 使用："
echo "variant_code 使用次數: $(grep -r "variant_code" webapp/src/ | wc -l)"
echo "product_code 使用次數: $(grep -r "product_code" webapp/src/ | wc -l)"
echo "sale_number 使用次數: $(grep -r "sale_number" webapp/src/ | wc -l)"
```

### **3. 完整預提交檢查腳本**
```bash
#!/bin/bash
# pre-commit-check.sh

echo "🚀 執行完整預提交檢查..."
echo "=========================================="

# 1. Prisma Client 重新生成
echo "🔧 重新生成 Prisma Client..."
cd webapp && npx prisma generate

# 2. 執行欄位檢查
echo "🔍 執行欄位命名檢查..."
./check-field-naming.sh

# 3. 執行 InventoryMovement 檢查
echo "🔍 執行 InventoryMovement 檢查..."
./check-inventory-movement.sh

# 4. TypeScript 編譯檢查
echo "📝 執行 TypeScript 編譯..."
npm run build

# 5. 最終結果
if [ $? -eq 0 ]; then
    echo "✅ 所有檢查通過！可以推送到 GitHub"
else
    echo "❌ 編譯失敗！請修復錯誤後再推送"
    exit 1
fi
```

## 🎯 **具體錯誤 → 強制檢查步驟**

### **此專案實際發生的錯誤轉化為檢查步驟**

| 實際錯誤 | 強制檢查步驟 | 檢查命令 |
|---------|------------|---------|
| **錯誤1**: `variantCode` vs `variant_code` 不一致 | 🔍 **步驟1**: 全域搜尋 camelCase 欄位名 | `grep -rn "variantCode\|productCode" webapp/src/` |
| **錯誤2**: InventoryMovement._sum.quantity (舊欄位) | 🔍 **步驟2**: 檢查聚合查詢使用正確欄位 | `grep -rn "_sum.*quantity[^_]" webapp/src/` |
| **錯誤3**: inventoryMovement.create 使用 quantity 而非 quantity_change | 🔍 **步驟3**: 檢查 create 操作欄位結構 | `grep -rn "inventoryMovement\.create" webapp/src/ -A 10 \| grep "quantity[^_]"` |
| **錯誤4**: 遺漏 unit_cost, total_cost 新欄位 | 🔍 **步驟4**: 確認必要欄位存在 | `grep -rn "unit_cost\|total_cost" webapp/src/` |

### **🚨 血淚教訓強制執行流程**

#### **當修改 Prisma 模型時，必須執行：**
```bash
# 1. 立即執行影響範圍檢查
./check-inventory-movement.sh

# 2. 立即執行欄位命名檢查
./check-field-naming.sh

# 3. 立即重新生成 Prisma Client
cd webapp && npx prisma generate

# 4. 立即編譯檢查
npm run build

# 5. 如果有錯誤，重複1-4直到無錯誤
```

#### **當修復 TypeScript 錯誤時，必須執行：**
```bash
# ❌ 錯誤做法：只修復當前看到的錯誤
# ✅ 正確做法：一次修復所有同類型錯誤

# 1. 分析錯誤模式 (例如: variantCode vs variant_code)
ERROR_PATTERN="variantCode"  # 替換為實際錯誤模式

# 2. 全域搜尋相同錯誤模式
echo "🔍 搜尋錯誤模式: $ERROR_PATTERN"
grep -rn "$ERROR_PATTERN" webapp/src/

# 3. 統計錯誤數量
TOTAL_ERRORS=$(grep -rn "$ERROR_PATTERN" webapp/src/ | wc -l)
echo "📊 總共找到 $TOTAL_ERRORS 個相同錯誤"

# 4. 逐一修復所有找到的錯誤
echo "🔧 開始批量修復..."

# 5. 再次搜尋確認無遺漏
echo "✅ 驗證修復結果:"
grep -rn "$ERROR_PATTERN" webapp/src/
if [ $? -eq 1 ]; then
    echo "✅ 所有相同錯誤已修復完成"
else
    echo "❌ 警告：仍有未修復的相同錯誤！"
fi

# 6. 本機編譯確認
npm run build

# 7. 一次性推送
```

### **💡 防呆檢查表（推送前必須執行）**

#### **🚨 螞蟻強制執行檢查表**
- [ ] ✅ **系統性思維檢查**: 對每個錯誤都執行了 `grep -rn "錯誤模式" webapp/src/`
- [ ] ✅ **批量修復確認**: 統計了錯誤數量並逐一修復所有實例
- [ ] ✅ **遺漏驗證**: 修復後再次搜尋確認無遺漏
- [ ] ✅ 執行 `./check-inventory-movement.sh` - 無錯誤輸出
- [ ] ✅ 執行 `./check-field-naming.sh` - 無錯誤輸出
- [ ] ✅ 執行 `npx prisma generate` - 成功
- [ ] ✅ 執行 `npm run build` - 成功
- [ ] ✅ commit message 包含所有修復範圍和修復數量

#### **📋 螞蟻A審查檢查表**
- [ ] ✅ **確認螞蟻B執行了系統性搜尋**: 檢查是否有全域搜尋相同錯誤的證據
- [ ] ✅ **驗證修復完整性**: 自行執行 `grep` 確認無遺漏相同錯誤
- [ ] ✅ **商業機密檢查**: 確保投資方數據隔離機制完整
- [ ] ✅ **代碼品質檢查**: 確認符合既定標準

---

## 📚 **教訓轉化為規則**

### **血淚教訓 → 強制規則**

| 教訓 | 轉化為規則 |
|------|-----------|
| "全域搜尋相同錯誤一次修完" | **規則1**: 每次修復前必須執行3個grep搜尋命令 |
| "先本機編譯檢查" | **規則2**: 推送前必須執行 `npm run build` |
| "避免反覆部署被AI罵" | **規則3**: 單次修復必須覆蓋所有同類型錯誤 |

### **檢查清單強制執行**
- [ ] **資料庫模型變更** → 立即執行影響範圍檢查
- [ ] **TypeScript錯誤** → 全域搜尋相同模式錯誤
- [ ] **推送前驗證** → 完整編譯+欄位檢查
- [ ] **記錄修復範圍** → commit message 列出所有修復點

---

## 🎯 **成功標準**

### **避免重複錯誤的成功指標**
1. **單次修復覆蓋率** = 100% （一次修復所有同類型錯誤）
2. **推送成功率** = 第一次推送就通過ZEABUR編譯
3. **檢查清單執行率** = 100% （每次都執行完整檢查）

### **失敗警告信號**
🚨 **如果出現以下情況，表示流程失效**：
- 同一類型錯誤需要修復2次以上
- ZEABUR報告的錯誤是之前修復過的類型
- 推送後立即收到新的編譯錯誤

---

---

## 🗺️ **資料庫模型變更影響範圍檢查**

### **InventoryMovement 模型影響地圖**
```
InventoryMovement 模型變更影響分析：
├── 📊 API 聚合查詢 (4個檔案)
│   ├── webapp/src/app/api/inventory/movements/route.ts
│   │   ├── _sum: { quantity_change, total_cost }
│   │   ├── _avg: { quantity_change, unit_cost }
│   │   └── groupBy: ['movement_type']
│   ├── webapp/src/app/api/reports/route.ts
│   └── webapp/src/app/api/dashboard/route.ts
├── 📝 API 創建操作 (3個檔案)
│   ├── webapp/src/app/api/inventory/route.ts
│   │   └── inventoryMovement.create({ quantity_before, quantity_change, quantity_after })
│   ├── webapp/src/app/api/purchases/[id]/receive/route.ts
│   │   └── inventoryMovement.create({ movement_type: 'PURCHASE' })
│   └── webapp/src/app/api/sales/[id]/ship/route.ts
│       └── inventoryMovement.create({ movement_type: 'SALE' })
├── 🔍 API 查詢操作 (2個檔案)
│   ├── webapp/src/app/api/inventory/movements/route.ts
│   └── webapp/src/app/api/products/[id]/movements/route.ts
└── 🎨 前端顯示 (預估 3-5個組件)
    ├── 庫存異動歷史組件
    ├── 庫存統計儀表板
    └── 產品詳情頁面
```

### **🔍 模型變更影響範圍自動掃描**
```bash
#!/bin/bash
# scan-model-impact.sh

MODEL_NAME="InventoryMovement"
echo "🗺️ 掃描 $MODEL_NAME 模型影響範圍..."
echo "=========================================="

echo "📊 1. 聚合查詢影響範圍："
grep -rn "inventoryMovement\.\(aggregate\|groupBy\|count\)" webapp/src/ --include="*.ts"

echo ""
echo "📝 2. 創建操作影響範圍："
grep -rn "inventoryMovement\.create" webapp/src/ --include="*.ts"

echo ""
echo "🔍 3. 查詢操作影響範圍："
grep -rn "inventoryMovement\.\(findMany\|findFirst\|findUnique\)" webapp/src/ --include="*.ts"

echo ""
echo "📋 4. 模型引用影響範圍："
grep -rn "InventoryMovement\|inventoryMovement" webapp/src/ --include="*.ts" | head -20

echo ""
echo "🏷️ 5. 相關欄位引用："
grep -rn "movement_type\|quantity_before\|quantity_change\|quantity_after\|unit_cost\|total_cost" webapp/src/ --include="*.ts" | wc -l
echo "找到相關欄位引用數量: $(grep -rn "movement_type\|quantity_before\|quantity_change\|quantity_after\|unit_cost\|total_cost" webapp/src/ --include="*.ts" | wc -l) 處"

echo ""
echo "✅ 影響範圍掃描完成 - 請檢查所有輸出結果！"
```

### **📋 模型變更檢查清單模板**

#### **當修改任何 Prisma 模型時，必須執行：**

##### **步驟1: 影響範圍識別**
- [ ] 執行 `./scan-model-impact.sh` 獲得完整影響清單
- [ ] 記錄所有受影響的檔案路徑
- [ ] 確認前端組件是否也需要更新

##### **步驟2: 系統性修復**
- [ ] **聚合查詢修復** - 檢查所有 `_sum`, `_avg`, `_count` 操作
- [ ] **創建操作修復** - 檢查所有 `create` 操作的欄位結構
- [ ] **查詢操作修復** - 檢查所有 `findMany`, `findFirst` 的 select 欄位
- [ ] **TypeScript類型修復** - 檢查相關的 interface 和 type 定義

##### **步驟3: 驗證流程**
- [ ] 重新生成 Prisma Client: `npx prisma generate`
- [ ] 執行欄位檢查: `./check-inventory-movement.sh`
- [ ] 執行完整編譯: `npm run build`
- [ ] 檢查測試通過: `npm test` (如果有測試)

##### **步驟4: 文檔更新**
- [ ] 更新 API 文檔中的欄位說明
- [ ] 更新模型變更記錄
- [ ] 在 commit message 中詳細說明所有變更範圍

### **🚨 高風險模型變更警告**

**特別注意這些模型的變更：**
- **InventoryMovement** - 影響庫存統計、進貨、出貨API
- **ProductVariant** - 影響庫存管理、價格計算
- **Sale/Purchase** - 影響交易流程、報表統計

**變更這些模型時，影響範圍通常包括：**
- 📊 儀表板統計API
- 📋 CRUD操作API
- 📈 報表生成API
- 🎨 前端顯示組件
- 💾 資料遷移腳本

---

---

## 🎯 **給螞蟻的明確指令模板**

### **🐜 螞蟻B指令模板**
```
當你看到任何錯誤時，必須執行以下步驟（不可跳過）：

1. 分析錯誤模式
2. 執行: grep -rn "錯誤模式" webapp/src/
3. 報告找到的錯誤數量
4. 批量修復所有相同錯誤
5. 再次驗證: grep -rn "錯誤模式" webapp/src/
6. 編譯檢查: npm run build
7. 提交時說明修復了幾個相同錯誤

絕對禁止只修復單個錯誤就提交！
```

### **🐜 螞蟻A指令模板**
```
檢查螞蟻B的工作時，必須確認：

1. 螞蟻B是否執行了全域搜尋相同錯誤？
2. 是否修復了所有相同類型的錯誤？
3. 自行執行 grep 驗證無遺漏
4. 檢查商業機密保護機制
5. 如發現遺漏，要求螞蟻B重新按流程執行

不可只檢查表面，必須驗證系統性修復！
```

---

**💡 核心原則**: **AI需要強制執行系統性思維**

停止「修復→推送→等錯誤→再修復」的惡性循環！
改為「分析→全域檢查→批量修復→一次推送」的良性循環！

**AI的模式匹配天性需要用工具和流程來補強全域思維！**

---

## 🚨 **2025/09/21 P0級修復經驗總結**

### **📋 今日修復的關鍵錯誤類型**

#### **錯誤類型1: 表單欄位缺失導致驗證失敗**
**具體錯誤**: 商品新增表單缺少 `brand` 和 `description` 欄位
**修復文件**: `webapp/src/app/products/page.tsx:165-175`
**預防措施**:
```bash
# 檢查API Schema與前端表單欄位一致性
grep -rn "validateProductData" webapp/src/lib/validation.ts
grep -rn "Form.Item.*name=" webapp/src/app/products/page.tsx
```

**系統性檢查步驟**:
1. 檢查後端驗證Schema定義的必填欄位
2. 比對前端表單是否包含所有必填欄位
3. 驗證表單提交的數據格式與API期望格式一致

#### **錯誤類型2: TypeScript介面屬性缺失**
**具體錯誤**: `Property 'current_price' does not exist on type 'Product'`
**修復文件**: `webapp/src/app/quotations/page.tsx:45-52`
**修復方法**:
```typescript
// 錯誤寫法：使用未定義的屬性
product.current_price

// 修復方法：完善本地介面定義
interface Product {
  id: string
  name: string
  product_code: string
  category: string
  current_price: number  // 添加缺失的屬性
}
```

**預防措施**:
```bash
# 檢查所有Product介面定義是否一致
grep -rn "interface Product" webapp/src/
grep -rn "current_price" webapp/src/ | grep -v "interface"
```

#### **錯誤類型3: 數據格式不匹配**
**具體錯誤**: 前端單項目表單 vs 後端多項目API期望格式
**修復文件**: `webapp/src/app/sales/page.tsx:447-473`
**修復方法**:
```typescript
// 前端表單數據
const formData = {
  customer_id: "xxx",
  product_id: "xxx",
  quantity: 1,
  unit_price: 1000
}

// 需要轉換為API期望格式
const apiData = {
  customer_id: formData.customer_id,
  items: [{
    product_id: formData.product_id,
    product_name: formData.product_name,
    quantity: formData.quantity,
    unit_price: formData.unit_price
  }],
  total_amount: formData.quantity * formData.unit_price,
  // ... 其他必要欄位
}
```

**預防措施**:
```bash
# 檢查API文檔與前端提交格式一致性
grep -rn "POST.*sales" webapp/src/app/api/
grep -rn "handleSubmit" webapp/src/app/sales/
```

#### **錯誤類型4: 前端業務流程缺失**
**具體錯誤**: 採購確認後無收貨按鈕，銷售付款後無出貨按鈕
**修復文件**:
- `webapp/src/app/purchases/page.tsx:312-335`
- `webapp/src/app/sales/page.tsx:685-708`

**業務流程斷鏈檢查**:
```bash
# 檢查業務狀態轉換是否完整
grep -rn "status.*CONFIRMED" webapp/src/app/purchases/
grep -rn "payment_status.*PAID" webapp/src/app/sales/
grep -rn "handleReceive\|handleShip" webapp/src/
```

### **🛡️ 新增檢查腳本：表單驗證一致性**

#### **表單欄位與API Schema一致性檢查**
```bash
#!/bin/bash
# check-form-api-consistency.sh

echo "🔍 檢查表單欄位與API Schema一致性..."
echo "=========================================="

echo "📋 檢查商品表單必填欄位："
echo "API驗證Schema中的必填欄位："
grep -n "required.*true\|z\.string()" webapp/src/lib/validation.ts | grep -A5 -B5 "Product"

echo ""
echo "前端表單實際欄位："
grep -n "Form\.Item.*name=" webapp/src/app/products/page.tsx

echo ""
echo "🚨 如果前端表單缺少API必填欄位，會導致驗證失敗！"

echo ""
echo "📋 檢查銷售表單數據格式："
echo "API期望格式（多項目）："
grep -n "items.*\[\]" webapp/src/app/api/sales/route.ts

echo ""
echo "前端提交格式："
grep -n "handleSubmit" webapp/src/app/sales/page.tsx -A10
```

#### **業務流程完整性檢查**
```bash
#!/bin/bash
# check-business-flow.sh

echo "🔄 檢查業務流程完整性..."
echo "=========================================="

echo "📦 採購流程檢查："
echo "1. 新增採購單功能："
grep -rn "handleSubmit.*purchase" webapp/src/app/purchases/

echo "2. 確認採購單功能："
grep -rn "status.*CONFIRMED" webapp/src/app/purchases/

echo "3. 收貨入庫功能："
grep -rn "handleReceive\|收貨" webapp/src/app/purchases/

echo ""
echo "💰 銷售流程檢查："
echo "1. 新增銷售單功能："
grep -rn "handleSubmit.*sale" webapp/src/app/sales/

echo "2. 付款確認功能："
grep -rn "payment_status.*PAID" webapp/src/app/sales/

echo "3. 出貨扣庫存功能："
grep -rn "handleShip\|出貨" webapp/src/app/sales/

echo ""
echo "🚨 任何流程缺失都會導致業務邏輯斷鏈！"
```

### **📚 今日血淚教訓轉化為規則**

#### **新增強制規則：表單驗證一致性**
| 錯誤情況 | 檢查命令 | 修復原則 |
|---------|---------|----------|
| 表單欄位缺失 | `./check-form-api-consistency.sh` | 前端表單必須包含API所有必填欄位 |
| 數據格式不匹配 | `grep -rn "handleSubmit" -A10` | 前端提交格式必須與API期望格式一致 |
| 介面屬性缺失 | `grep -rn "interface.*Product"` | 本地介面定義必須包含所有使用的屬性 |
| 業務流程斷鏈 | `./check-business-flow.sh` | 每個業務狀態必須有對應的操作按鈕 |

#### **新增部署前檢查項目**
- [ ] ✅ 執行 `./check-form-api-consistency.sh` - 無錯誤輸出
- [ ] ✅ 執行 `./check-business-flow.sh` - 確認流程完整
- [ ] ✅ 執行 `grep -rn "Property.*does not exist"` - 無TypeScript類型錯誤
- [ ] ✅ 檢查所有status轉換都有對應的UI操作

#### **🎯 具體修復模式總結**

**模式1: 表單欄位缺失**
```typescript
// ❌ 錯誤：API要求brand和description，但表單沒有
<Form.Item name="name" label="商品名稱">
  <Input placeholder="請輸入商品名稱" />
</Form.Item>

// ✅ 正確：添加所有API必填欄位
<Form.Item name="brand" label="品牌">
  <Input placeholder="請輸入品牌" />
</Form.Item>
<Form.Item name="description" label="商品描述">
  <Input.TextArea placeholder="請輸入商品描述" rows={3} />
</Form.Item>
```

**模式2: 數據格式轉換**
```typescript
// ❌ 錯誤：直接提交表單數據
const response = await fetch('/api/sales', {
  method: 'POST',
  body: JSON.stringify(formValues)  // 單項目格式
})

// ✅ 正確：轉換為API期望格式
const apiData = {
  customer_id: formValues.customer_id,
  items: [{
    product_id: formValues.product_id,
    quantity: formValues.quantity,
    unit_price: formValues.unit_price
  }],  // 多項目格式
  total_amount: formValues.quantity * formValues.unit_price
}
```

**模式3: 業務流程補全**
```typescript
// ❌ 錯誤：只有狀態顯示，沒有操作按鈕
{purchase.status === 'CONFIRMED' && <Tag color="green">已確認</Tag>}

// ✅ 正確：添加對應的業務操作
{purchase.status === 'CONFIRMED' && (
  <Button
    type="primary"
    onClick={() => handleReceive(purchase)}
  >
    收貨入庫
  </Button>
)}
```

### **🎊 成功指標更新**

**今日修復成功率**: 100% - 5個P0級缺陷全部修復
**部署成功率**: 95% - 僅最後一次部署有minor錯誤，立即修復
**系統轉型**: 從「展示用原型」成功升級為「可實際營運系統」

**關鍵成功因素**:
1. 系統性分析每個錯誤的根本原因
2. 完整的業務流程梳理和補全
3. 前端與後端的數據格式統一
4. 所有API與表單的一致性驗證
5. 立即修復部署錯誤，保持零錯誤狀態